
https://dev.mysql.com/doc/refman/5.7/en/select-optimization.html


CREATE TABLE...AS SELECT
https://dev.mysql.com/doc/refman/5.7/en/create-table-select.html

INSERT INTO...SELECT
https://dev.mysql.com/doc/refman/5.7/en/insert-select.html

WHERE clauses in DELETE statements
https://dev.mysql.com/doc/refman/5.7/en/delete.html

这些语句有额外的性能考虑，因为它们将写操作与面向读的查询操作结合起来

join pushdown optimization
https://dev.mysql.com/doc/refman/5.7/en/mysql-cluster-options-variables.html#ndb_join_pushdown-conditions


优化思路如下
1.考虑是否能加索引
2.尽量独立查询的各个部分，比如函数调用
根据查询的结构，可以对结果集中的每一行调用一次函数，或者对表中的每一行调用一次函数
3.减小全表扫描行数
https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_full_table_scan
4.定期使用ANALYZE table语句，使表统计信息保持最新，这样优化器就拥有了构建高效执行计划所需的信息
5.了解特定于每个表的存储引擎的调整技术、索引技术和配置参数
InnoDB和MyISAM都有一套在查询中启用和保持高性能的方法
https://dev.mysql.com/doc/refman/5.7/en/optimizing-innodb-queries.html
https://dev.mysql.com/doc/refman/5.7/en/optimizing-queries-myisam.html
6.InnoDB事务查询优化
Section 8.5.3, “Optimizing InnoDB Read-Only Transactions”.
https://dev.mysql.com/doc/refman/5.7/en/innodb-performance-ro-txn.html
7.避免以难以理解的方式转换查询，尤其是当优化器自动执行某些相同的转换时
8.处理lock问题，查询变慢可能是由于多个session在争抢同一个锁



Optimizing Queries with EXPLAIN
https://dev.mysql.com/doc/refman/5.7/en/using-explain.html




一：WHERE Clause Optimization
https://dev.mysql.com/doc/refman/5.7/en/where-optimization.html

对于单个MyISAM或者MEMORY表，不带WHERE的count(*)查询是直接从表信息中返回结果
或者count(expression)，其中expression需要NOT NULL，注意：只针对单表且不带WHERE


mysql> SELECT * FROM t ;
+----+-------+
| id | col_a |
+----+-------+
|  4 | NULL  |
|  5 | NULL  |
|  6 | NULL  |
|  1 | A     |
|  3 | C     |
|  2 | NULL  |
+----+-------+
6 rows in set (0.00 sec)

mysql> SELECT count(*), count(1), count(t.col_a), count(NULL) FROM t;
+----------+----------+----------------+-------------+
| count(*) | count(1) | count(t.col_a) | count(NULL) |
+----------+----------+----------------+-------------+
|        6 |        6 |              3 |           0 |
+----------+----------+----------------+-------------+
1 row in set (0.00 sec)


如果不使用GROUP BY或聚合函数，HAVING将与WHERE合并


constant table
1.An empty table or a table with one row.
2.


Cause: com.mysql.cj.jdbc.exceptions.MySQLTransactionRollbackException: Lock wait timeout exceeded; try restarting transaction





